
# 命令行参数解析

argparse.h 是命令行解析所需的头文件, 这是一个 Head-only 的文件

下面是一个简单且全面的使用示例

```c
#include <xbox/argparse.h>

int main(int argc, const char **argv)
{
    int i;
    int t;
    char *s, *dest;
    int src;
    argparse_option options[] = {
        XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
        XBOX_ARG_INT(&i, [-i][--input][help="input file"]),
        XBOX_ARG_INT(&t,[-t][--target][help="target file"]),
        XBOX_ARG_STR(&s,[-s][--string]),
        XBOX_ARG_STR_GROUP(&dest,[name=dest][help="destination"]),
        XBOX_ARG_INT_GROUP(&src,[name=src][help="source"]),
        XBOX_ARG_END()
    }; 

    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, 0);
    XBOX_argparse_describe(&parser, "ls", "\nA brief description of what the program does and how it works.", "\nAdditional description of the program after the description of the arguments.");
    XBOX_argparse_parse(&parser, argc, argv);

    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    if (XBOX_ismatch(&parser, "input")) {
        printf("i = %d\n",i);
    }
    if (XBOX_ismatch(&parser, "target")) {
        printf("t = %d\n",t);
    }
    if (XBOX_ismatch(&parser, "string")) {
        printf("s = %s\n",s);
    }
    if (XBOX_ismatch(&parser, "dest")) {
        printf("dest = %s\n",dest);
    }
    if (XBOX_ismatch(&parser, "src")) {
        printf("src = %d\n",src);
    }
    XBOX_free_argparse(&parser);
    
    free(s);
    free(dest);
    return 0;
}
```

## 用法说明

以上面的示例为例, 我们需要先定义变量然后构建一个 options 并与变量绑定

```c
int i;
int t;
char *s, *dest;
int src;
argparse_option options[] = {
    XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
    XBOX_ARG_INT(&i, [-i][--input][help="input file"]),
    XBOX_ARG_INT(&t,[-t][--target][help="target file"]),
    XBOX_ARG_STR(&s,[-s][--string]),
    XBOX_ARG_STR_GROUP(&dest,[name=dest][help="destination"]),
    XBOX_ARG_INT_GROUP(&src,[name=src][help="source"]),
    XBOX_ARG_END()
}; 
```

这里的 `XBOX_ARG*` 开头的是宏, 第一个位置用于参数绑定, 后面的内容会被展开为字符串用于后续的解析

argparse.h 一共提供了六种宏

- **XBOX_ARG_BOOLEAN**: 适用于单参数, 例如 `-h`, 后面不需要跟其他参数信息
- **XBOX_ARG_INT**: 表示参数接收的应该是一个 int 类型的数字, 例如 `-i 100`
- **XBOX_ARG_STR**: 表示参数接收的应该是一个 char* 类型的字符串, 例如 `-s "hello world"` `-s nihao`
- **XBOX_ARG_INT_GROUP**: 表示接收一个组, 组的数据类型是 int
- **XBOX_ARG_STR_GROUP**: 表示接收一个组, 组的数据类型是 char*
- **XBOX_ARG_END**: 表示结束, 添加在 options 数组的结尾

组即不需要 `-` `--` 指定接收的正常参数, 以上面的例子为例, 如果命令行传参为: `./main abc 100`, 其中 "abc" 会被 dest 组接收, 100 会被 src 组接收

上述 5 种参数宏分别对应不同的使用场景, 您应该合理的使用和传参, 即 int 对应 INT, char* 对应 STR

宏的第二个参数是该参数对应的解析配置, 其完整语法如下: `[-h][--help][name=abc][help="show help information"]`, 所有配置由一对 `[]` 包裹, `[]` 与 `[]`之间可以有空格.

有 4 种合理的写法

- `[-h]`: 表示短参数 h
- `[--help]`: 表示长参数 help
- `[name=abc]`: 表示此参数命名为 abc
- `[help="some info"]`: 表示参数的帮助信息

其中需要注意如下几点

- 短参数-h 非必须, help 非必须, 长参数与name至少有一个
- 长参数和name如果同时存在则必须相同, 即 `[--help]` `[name=help]`
- 如果只有长参数, 则name为长参数去掉 `--` 的名字, 即 `--cherry-pick` -> name 为 `cherry-pick`
- 长参数(包括--)至少 4 字节, 即 `--h` 不合法, `--ha` 合法
- 长参数默认只允许 `a-z_-` 的组合, 如果您希望使用其他字符你可手动修改 `check_valid_character` 函数
- 对于字符串开头结尾的 `"` 并不重要, 如果开头结尾同时存在 `"` 则会默认去掉, 即 `[help=ni hao ya]` 和 `[help="ni hao ya"]` 是等价的

之后您只需要构建对象, 初始化并解析即可

```c
XBOX_argparse parser;
XBOX_argparse_init(&parser, options, 0);
XBOX_argparse_describe(&parser, "ls", "\ndescription", "\naaa.");
XBOX_argparse_parse(&parser, argc, argv);
```

其中有两点需要说明: 

`XBOX_argparse_describe` 的2 3 4位置的参数分别为 解析器的名字, 简要描述, 结尾描述

`XBOX_argparse_init` 第三个参数为 flag 标记位, 用于控制解析时的选项, 默认传 0 即可.

- **XBOX_ARGPARSE_IGNORE_WARNING**: 忽略警告
- **XBOX_ARGPARSE_ENABLE_STICK**: 允许参数粘连 `-O1 -Iinclude/`
- **XBOX_ARGPARSE_ENABLE_EQUAL**: 允许参数等号 `-i=123`
- **XBOX_ARGPARSE_ENABLE_MULTI**: 允许多个分离参数 `-D __KERNEL__ -D __GNU__`
- **XBOX_ARGPARSE_ACCEPT_MORE**: 允许参数过多, 比如group只接受 dest src, 但是传了 100 200 300
- **XBOX_ARGPARSE_ENABLE_ARG_STICK**: 允许boolean类型参数粘连 `curl -Ls xxx`

您可以使用或运算将他们组合, 并传入 flag

```c
XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_IGNORE_WARNING|XBOX_ARGPARSE_ENABLE_ARG_STICK);
```

**请注意**: XBOX_ARGPARSE_ENABLE_ARG_STICK 的处理和 XBOX_ARGPARSE_ENABLE_STICK XBOX_ARGPARSE_ENABLE_EQUAL 存在冲突, 从合理性上来说也不应该支持类似 `-Lsi=123ql=100` 的解析模式, 仅支持 XBOX_ARG_BOOLEAN 类型传递, 请合理使用

---

`XBOX_ismatch` 函数用于判断是否接收到了参数, 您可以采用如下写法, 应该是比较清晰直观的

```c
if (XBOX_ismatch(&parser, "help")) {
    XBOX_argparse_info(&parser);
}
if (XBOX_ismatch(&parser, "input")) {
    printf("i = %d\n",i);
}
if (XBOX_ismatch(&parser, "target")) {
    printf("t = %d\n",t);
}
if (XBOX_ismatch(&parser, "string")) {
    printf("s = %s\n",s);
}
if (XBOX_ismatch(&parser, "dest")) {
    printf("dest = %s\n",dest);
}
if (XBOX_ismatch(&parser, "src")) {
    printf("src = %d\n",src);
}
XBOX_free_argparse(&parser);

free(s);
free(dest);
```

这里提供了一个函数 `XBOX_argparse_info` 用于帮助信息的输出, 建议您在 options 中添加 -h 选项并将其绑定到 XBOX_argparse_info 函数, 用于辅助帮助信息的输出

最后使用 `XBOX_free_argparse` 释放内存, 对于 char* 类型的参数, 即是用 `XBOX_ARG_STR*` 的参数, 注意结束之后使用 free 释放内存

接下来您利用这些参数去处理您程序真正想要完成的事情了

## 用法实例

如果您的参数解析器初始化存在问题, 或者解析过程出现错误, 程序会输出相应的错误提示信息, 并且内部会自动调用 free 释放内存, 您无需担心内存泄漏的问题

下面是根据上述例子的解析情况

- 正常情况

  ```bash
  $ ./src/ls/ls 123 456
  dest = 123
  src = 456

  $ ./src/ls/ls 123 -s 123 -i 100
  i = 100
  s = 123
  dest = 123

  $ ./src/ls/ls 123 -s 123 -i 100 900
  i = 100
  s = 123
  dest = 123
  src = 900
  ```

- 传入的参数与 int 不匹配

  ```bash
  $ ./src/ls/ls 123 abc
  Error: argument assign to be int but get [abc]

  $ ./src/ls/ls 123 123a1
  Error: argument assign to be int but get [123a1]
  ```

- 缺少参数

  ```bash
  $ ./src/ls/ls 123 -s
  Error: option [--string] needs one argument
  ```

## 解析扩展选项

如果您希望扩展解析时选项, 您可修改 flag 标记位

- **XBOX_ARGPARSE_IGNORE_WARNING**: 忽略警告
- **XBOX_ARGPARSE_ENABLE_STICK**: 允许参数粘连 `-O1 -Iinclude/`
- **XBOX_ARGPARSE_ENABLE_EQUAL**: 允许参数等号 `-i=123`
- **XBOX_ARGPARSE_ENABLE_MULTI**: 允许多个分离参数 `-D __KERNEL__ -D __GNU__`
- **XBOX_ARGPARSE_ACCEPT_MORE**: 允许参数过多, 比如group只接受 dest src, 但是传了 100 200 300
- **XBOX_ARGPARSE_ENABLE_ARG_STICK**: 允许boolean类型参数粘连 `curl -Ls xxx`

您可以使用或运算将他们组合, 并传入 flag

```c
XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_IGNORE_WARNING|XBOX_ARGPARSE_ENABLE_ARG_STICK);
```

**请注意**: XBOX_ARGPARSE_ENABLE_ARG_STICK 的处理和 XBOX_ARGPARSE_ENABLE_STICK XBOX_ARGPARSE_ENABLE_EQUAL 存在冲突, 从合理性上来说也不应该支持类似 `-Lsi=123ql=100` 的解析模式, 仅支持 XBOX_ARG_BOOLEAN 类型传递, 请合理使用

### XBOX_ARGPARSE_IGNORE_WARNING

如果启用此选项, 解析时会忽略所有危险信息, 例如

```bash
# 将下一个短参数当作解析对象
$ ./src/ls/ls -s -i
Warning: [-i] will be passed as the argument for [-s]
s = -i

# 多个参数重复出现且未开启 XBOX_ARGPARSE_ENABLE_MULTI
$ ./src/ls/ls -i 100 -i 200
Warning: multi argument detected for [input]
i = 200
```

### XBOX_ARGPARSE_ENABLE_STICK

允许参数与选项粘连

```bash
$ ./src/ls/ls -i100
i = 100
```

### XBOX_ARGPARSE_ENABLE_EQUAL

允许等号赋值

```bash
$ ./src/ls/ls -s="hello world"
s = hello world
$ ./src/ls/ls -s=hello
s = hello
```

### XBOX_ARGPARSE_ENABLE_MULTI

如果您希望允许多个分离参数, 即保存为数组, 你需要修改一下绑定的变量, 例如下例

```c
#include <xbox/argparse.h>

int main(int argc, const char **argv)
{
    char **defines = NULL;
    int *integers = NULL;
    argparse_option options[] = {
        XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
        XBOX_ARG_INT(&integers, [-i][--input][help="input file"]),
        XBOX_ARG_STR(&defines,[-D][--define][help="defination macros"]),
        XBOX_ARG_END()
    }; 

    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_MULTI);
    XBOX_argparse_describe(&parser,"pwd","","");
    XBOX_argparse_parse(&parser, argc, argv);

    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    
    int d = XBOX_ismatch(&parser, "define");
    printf("define = ");
    for (int i=0;i<d;i++) {
        printf("%s ", defines[i]);
        free(defines[i]);
    }
    free(defines);
    printf("\n");

    int k = XBOX_ismatch(&parser, "input");
    printf("integer = ");
    for (int i=0;i<k;i++) {
        printf("%d ", integers[i]);
    }
    printf("\n");
    free(integers);
    XBOX_free_argparse(&parser);
    return 0;
}
```

```bash
$ ./src/pwd/pwd -D __KERNEL -D __GNU__ -i 100 -i 200 -i 300
define = __KERNEL __GNU__
integer = 100 200 300
```

### 组合

您可组合一些情况, 例如 `XBOX_ARGPARSE_ENABLE_STICK | XBOX_ARGPARSE_ENABLE_MULTI`

```bash
$ ./src/pwd/pwd -D__KERNEL -D__GNU__ -i 100 -i 200 -i 300
define = __KERNEL __GNU__
integer = 100 200 300
```

## 参考

- [argparse](https://github.com/cofyc/argparse)
- [fflags](https://github.com/SuperH-0630/fflags)