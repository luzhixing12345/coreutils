<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class='markdown-body'><h1>命令行参数解析</h1><p>xutils.h 是命令行解析所需的头文件, 这是一个 Head-only 的文件</p><p>下面是一个简单且全面的使用示例</p><pre><code class="language-c">#include &lt;xbox/xutils.h&gt;

int main(int argc, const char **argv)
{
    int i;
    int t;
    char *s, *dest;
    int src;
    argparse_option options[] = {
        XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
        XBOX_ARG_INT(&i, [-i][--input][help="input file"]),
        XBOX_ARG_INT(&t,[-t][--target][help="target file"]),
        XBOX_ARG_STR(&s,[-s][--string]),
        XBOX_ARG_STR_GROUP(&dest,[name=dest][help="destination"]),
        XBOX_ARG_INT_GROUP(&src,[name=src][help="source"]),
        XBOX_ARG_END()
    }; 
    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, 0);
    XBOX_argparse_describe(&parser, "ls", "\nA brief description of what the program does and how it works.", "\nAdditional description of the program after the description of the arguments.");
    XBOX_argparse_parse(&parser, argc, argv);
    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    if (XBOX_ismatch(&parser, "input")) {
        printf("i = %d\n",i);
    }
    if (XBOX_ismatch(&parser, "target")) {
        printf("t = %d\n",t);
    }
    if (XBOX_ismatch(&parser, "string")) {
        printf("s = %s\n",s);
    }
    if (XBOX_ismatch(&parser, "dest")) {
        printf("dest = %s\n",dest);
    }
    if (XBOX_ismatch(&parser, "src")) {
        printf("src = %d\n",src);
    }
    XBOX_free_argparse(&parser);
    free(s);
    free(dest);
    return 0;
}</code></pre><h2>用法说明</h2><p>以上面的示例为例, 我们需要先定义变量然后构建一个 options 并与变量绑定</p><pre><code class="language-c">int i;
int t;
char *s, *dest;
int src;
argparse_option options[] = {
    XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
    XBOX_ARG_INT(&i, [-i][--input][help="input file"]),
    XBOX_ARG_INT(&t,[-t][--target][help="target file"]),
    XBOX_ARG_STR(&s,[-s][--string]),
    XBOX_ARG_STR_GROUP(&dest,[name=dest][help="destination"]),
    XBOX_ARG_INT_GROUP(&src,[name=src][help="source"]),
    XBOX_ARG_END()
};</code></pre><p>这里的 <code>XBOX_ARG*</code> 开头的是宏, 第一个位置用于参数绑定, 后面的内容会被展开为字符串用于后续的解析</p><p>xutils.h 一共提供了六种宏</p><ul><li><b>XBOX_ARG_BOOLEAN</b>: 适用于单参数, 例如 <code>-h</code>, 后面不需要跟其他参数信息</li></ul><ul><li><b>XBOX_ARG_INT</b>: 表示参数接收的应该是一个 int 类型的数字, 例如 <code>-i 100</code></li></ul><ul><li><b>XBOX_ARG_STR</b>: 表示参数接收的应该是一个 char* 类型的字符串, 例如 <code>-s "hello world"</code> <code>-s nihao</code></li></ul><ul><li><b>XBOX_ARG_INT_GROUP</b>: 表示接收一个组, 组的数据类型是 int</li></ul><ul><li><b>XBOX_ARG_STR_GROUP</b>: 表示接收一个组, 组的数据类型是 char*</li></ul><ul><li><b>XBOX_ARG_END</b>: 表示结束, 添加在 options 数组的结尾</li></ul><p>组即不需要 <code>-</code> <code>--</code> 指定接收的正常参数, 以上面的例子为例, 如果命令行传参为: <code>./main abc 100</code>, 其中 "abc" 会被 dest 组接收, 100 会被 src 组接收</p><p>上述 5 种参数宏分别对应不同的使用场景, 您应该合理的使用和传参, 即 int 对应 INT, char* 对应 STR</p><p>宏的第二个参数是该参数对应的解析配置, 其完整语法如下: <code>[-h][--help][name=abc][help="show help information"]</code>, 所有配置由一对 <code>[]</code> 包裹, <code>[]</code> 与 <code>[]</code>之间可以有空格.</p><p>有 4 种合理的写法</p><ul><li><code>[-h]</code>: 表示短参数 h</li></ul><ul><li><code>[--help]</code>: 表示长参数 help</li></ul><ul><li><code>[name=abc]</code>: 表示此参数命名为 abc</li></ul><ul><li><code>[help="some info"]</code>: 表示参数的帮助信息</li></ul><p>其中需要注意如下几点</p><ul><li>短参数-h 非必须, help 非必须, 长参数与name至少有一个</li></ul><ul><li>长参数和name如果同时存在则必须相同, 即 <code>[--help]</code> <code>[name=help]</code></li></ul><ul><li>如果只有长参数, 则name为长参数去掉 <code>--</code> 的名字, 即 <code>--cherry-pick</code> -> name 为 <code>cherry-pick</code></li></ul><ul><li>长参数(包括--)至少 4 字节, 即 <code>--h</code> 不合法, <code>--ha</code> 合法</li></ul><ul><li>长参数默认只允许 <code>a-z_-</code> 的组合, 如果您希望使用其他字符你可手动修改 <code>check_valid_character</code> 函数</li></ul><ul><li>对于字符串开头结尾的 <code>"</code> 并不重要, 如果开头结尾同时存在 <code>"</code> 则会默认去掉, 即 <code>[help=ni hao ya]</code> 和 <code>[help="ni hao ya"]</code> 是等价的</li></ul><p>之后您只需要构建对象, 初始化并解析即可</p><pre><code class="language-c">XBOX_argparse parser;
XBOX_argparse_init(&parser, options, 0);
XBOX_argparse_describe(&parser, "ls", "\ndescription", "\naaa.");
XBOX_argparse_parse(&parser, argc, argv);</code></pre><p>其中有两点需要说明:</p><p><code>XBOX_argparse_describe</code> 的2 3 4位置的参数分别为 解析器的名字, 简要描述, 结尾描述</p><p><code>XBOX_argparse_init</code> 第三个参数为 flag 标记位, 用于控制解析时的选项, 默认传 0 即可.</p><ul><li><b>XBOX_ARGPARSE_IGNORE_WARNING</b>: 忽略警告</li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_STICK</b>: 允许参数粘连 <code>-O1 -Iinclude/</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_EQUAL</b>: 允许参数等号 <code>-i=123</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_MULTI</b>: 允许多个分离参数 <code>-D __KERNEL__ -D __GNU__</code></li></ul><ul><li><b>XBOX_ARGPARSE_ACCEPT_MORE</b>: 允许参数过多, 比如group只接受 dest src, 但是传了 100 200 300</li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_ARG_STICK</b>: 允许boolean类型参数粘连 <code>curl -Ls xxx</code></li></ul><p>您可以使用或运算将他们组合, 并传入 flag</p><pre><code class="language-c">XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_IGNORE_WARNING|XBOX_ARGPARSE_ENABLE_ARG_STICK);</code></pre><p><b>请注意</b>: XBOX_ARGPARSE_ENABLE_ARG_STICK 的处理和 XBOX_ARGPARSE_ENABLE_STICK XBOX_ARGPARSE_ENABLE_EQUAL 存在冲突, 从合理性上来说也不应该支持类似 <code>-Lsi=123ql=100</code> 的解析模式, 仅支持 XBOX_ARG_BOOLEAN 类型传递, 请合理使用</p><hr><p><code>XBOX_ismatch</code> 函数用于判断是否接收到了参数, 您可以采用如下写法, 应该是比较清晰直观的</p><pre><code class="language-c">if (XBOX_ismatch(&parser, "help")) {
    XBOX_argparse_info(&parser);
}
if (XBOX_ismatch(&parser, "input")) {
    printf("i = %d\n",i);
}
if (XBOX_ismatch(&parser, "target")) {
    printf("t = %d\n",t);
}
if (XBOX_ismatch(&parser, "string")) {
    printf("s = %s\n",s);
}
if (XBOX_ismatch(&parser, "dest")) {
    printf("dest = %s\n",dest);
}
if (XBOX_ismatch(&parser, "src")) {
    printf("src = %d\n",src);
}
XBOX_free_argparse(&parser);

free(s);
free(dest);</code></pre><p>这里提供了一个函数 <code>XBOX_argparse_info</code> 用于帮助信息的输出, 建议您在 options 中添加 -h 选项并将其绑定到 XBOX_argparse_info 函数, 用于辅助帮助信息的输出</p><p>最后使用 <code>XBOX_free_argparse</code> 释放内存, 对于 char<i> 类型的参数, 即是用 `XBOX_ARG_STR</i>` 的参数, 注意结束之后使用 free 释放内存</p><p>接下来您利用这些参数去处理您程序真正想要完成的事情了</p><h2>用法实例</h2><p>如果您的参数解析器初始化存在问题, 或者解析过程出现错误, 程序会输出相应的错误提示信息, 并且内部会自动调用 free 释放内存, 您无需担心内存泄漏的问题</p><p>下面是根据上述例子的解析情况</p><ul><li>正常情况<pre><code class="language-bash">$ ./src/ls/ls 123 456
dest = 123
src = 456

$ ./src/ls/ls 123 -s 123 -i 100
i = 100
s = 123
dest = 123

$ ./src/ls/ls 123 -s 123 -i 100 900
i = 100
s = 123
dest = 123
src = 900</code></pre></li></ul><ul><li>传入的参数与 int 不匹配<pre><code class="language-bash">$ ./src/ls/ls 123 abc
Error: argument assign to be int but get [abc]

$ ./src/ls/ls 123 123a1
Error: argument assign to be int but get [123a1]</code></pre></li></ul><ul><li>缺少参数<pre><code class="language-bash">$ ./src/ls/ls 123 -s
Error: option [--string] needs one argument</code></pre></li></ul><h2>解析扩展选项</h2><p>如果您希望扩展解析时选项, 您可修改 flag 标记位</p><ul><li><b>XBOX_ARGPARSE_IGNORE_WARNING</b>: 忽略警告</li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_STICK</b>: 允许参数粘连 <code>-O1 -Iinclude/</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_EQUAL</b>: 允许参数等号 <code>-i=123</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_MULTI</b>: 允许多个分离参数 <code>-D __KERNEL__ -D __GNU__</code></li></ul><ul><li><b>XBOX_ARGPARSE_ACCEPT_MORE</b>: 允许参数过多, 比如group只接受 dest src, 但是传了 100 200 300</li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_ARG_STICK</b>: 允许boolean类型参数粘连 <code>curl -Ls xxx</code></li></ul><p>您可以使用或运算将他们组合, 并传入 flag</p><pre><code class="language-c">XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_IGNORE_WARNING|XBOX_ARGPARSE_ENABLE_ARG_STICK);</code></pre><p><b>请注意</b>: XBOX_ARGPARSE_ENABLE_ARG_STICK 的处理和 XBOX_ARGPARSE_ENABLE_STICK XBOX_ARGPARSE_ENABLE_EQUAL 存在冲突, 从合理性上来说也不应该支持类似 <code>-Lsi=123ql=100</code> 的解析模式, 仅支持 XBOX_ARG_BOOLEAN 类型传递, 请合理使用</p><h3>XBOX_ARGPARSE_IGNORE_WARNING</h3><p>如果启用此选项, 解析时会忽略所有危险信息, 例如</p><pre><code class="language-bash"># 将下一个短参数当作解析对象
$ ./src/ls/ls -s -i
Warning: [-i] will be passed as the argument for [-s]
s = -i

# 多个参数重复出现且未开启 XBOX_ARGPARSE_ENABLE_MULTI
$ ./src/ls/ls -i 100 -i 200
Warning: multi argument detected for [input]
i = 200</code></pre><h3>XBOX_ARGPARSE_ENABLE_STICK</h3><p>允许参数与选项粘连</p><pre><code class="language-bash">$ ./src/ls/ls -i100
i = 100</code></pre><h3>XBOX_ARGPARSE_ENABLE_EQUAL</h3><p>允许等号赋值</p><pre><code class="language-bash">$ ./src/ls/ls -s="hello world"
s = hello world
$ ./src/ls/ls -s=hello
s = hello</code></pre><h3>XBOX_ARGPARSE_ENABLE_MULTI</h3><p>如果您希望允许多个分离参数, 即保存为数组, 你需要修改一下绑定的变量, 例如下例</p><pre><code class="language-c">#include &lt;xbox/xutils.h&gt;

int main(int argc, const char **argv)
{
    char **defines = NULL;
    int *integers = NULL;
    argparse_option options[] = {
        XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
        XBOX_ARG_INT(&integers, [-i][--input][help="input file"]),
        XBOX_ARG_STR(&defines,[-D][--define][help="defination macros"]),
        XBOX_ARG_END()
    }; 
    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_MULTI);
    XBOX_argparse_describe(&parser,"pwd","","");
    XBOX_argparse_parse(&parser, argc, argv);
    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    int d = XBOX_ismatch(&parser, "define");
    printf("define = ");
    for (int i=0;i&lt;d;i++) {
        printf("%s ", defines[i]);
        free(defines[i]);
    }
    free(defines);
    printf("\n");
    int k = XBOX_ismatch(&parser, "input");
    printf("integer = ");
    for (int i=0;i&lt;k;i++) {
        printf("%d ", integers[i]);
    }
    printf("\n");
    free(integers);
    XBOX_free_argparse(&parser);
    return 0;
}</code></pre><pre><code class="language-bash">$ ./src/pwd/pwd -D __KERNEL -D __GNU__ -i 100 -i 200 -i 300
define = __KERNEL __GNU__
integer = 100 200 300</code></pre><h3>组合</h3><p>您可组合一些情况, 例如 <code>XBOX_ARGPARSE_ENABLE_STICK | XBOX_ARGPARSE_ENABLE_MULTI</code></p><pre><code class="language-bash">$ ./src/pwd/pwd -D__KERNEL -D__GNU__ -i 100 -i 200 -i 300
define = __KERNEL __GNU__
integer = 100 200 300</code></pre><h2>参考</h2><ul><li><a href="https://github.com/cofyc/argparse" target="_blank">argparse</a></li></ul><ul><li><a href="https://github.com/SuperH-0630/fflags" target="_blank">fflags</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../libXBX/快速使用" >libXBX</a><ul><li><a href="../../libXBX/快速使用" >快速使用</a></li></ul><ul><li><a href="../../libXBX/命令行参数解析" >命令行参数解析</a></li></ul><ul><li><a href="../../libXBX/cat" >cat</a></li></ul></li></ul><ul><li><a href="../../LinuxC/man" >LinuxC</a><ul><li><a href="../../LinuxC/man" >man</a></li></ul><ul><li><a href="../../LinuxC/文件IO" >文件IO</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../libXBX/快速使用","../../libXBX/cat","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
    <script type="module">
        const codeBlocks = document.querySelectorAll('.language-mermaid');
        codeBlocks.forEach(codeBlock => {
            codeBlock.classList.remove('language-mermaid');
            codeBlock.classList.add('mermaid');
        });
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>

</html>