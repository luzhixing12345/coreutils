<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class="header-navigator"><ul><li><a href="#h1-0">命令行参数解析</a><ul><li><a href="#h2-1">用法说明</a></li></ul><ul><li><a href="#h2-2">接收参数</a></li></ul><ul><li><a href="#h2-3">用法实例</a><ul><li><a href="#h3-4">正常情况</a></li></ul><ul><li><a href="#h3-5">传入的参数与int不匹配</a></li></ul><ul><li><a href="#h3-6">缺少参数</a></li></ul></li></ul><ul><li><a href="#h2-7">解析扩展选项</a><ul><li><a href="#h3-8">忽略警告</a></li></ul><ul><li><a href="#h3-9">参数与值粘连</a></li></ul><ul><li><a href="#h3-10">等号赋值</a></li></ul><ul><li><a href="#h3-11">分离参数</a></li></ul></li></ul><ul><li><a href="#h2-12">bool参数粘连</a></li></ul><ul><li><a href="#h2-13">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">命令行参数解析</h1><p><a href="https://github.com/luzhixing12345/xbox/blob/main/src/xargparse.h" target="_blank">xargparse.h</a> 是命令行解析所需的头文件, 这是一个 Head-only 的文件, 意味着您可以在主函数入口文件引用后直接使用, 但由于函数的声明的定义都写在 .h 中所以不要多次引入并参与链接</p><p>下面是一个简单且全面的使用示例</p><pre><code class="language-c">#include &lt;xbox/xargparse.h&gt;

int main(int argc, const char **argv) {
    int i;
    char *s, *dest;
    int src;
    int *other_numbers;
    argparse_option options[] = {XBOX_ARG_BOOLEAN(NULL, [-h][--help][help = "show help information"]),
                                 XBOX_ARG_BOOLEAN(NULL, [-v][--version][help = "show version"]),
                                 XBOX_ARG_INT(&i, [-i][--input][help = "input file"]),
                                 XBOX_ARG_STR(&s, [-s][--string]),
                                 XBOX_ARG_STR_GROUP(&dest, [name = dest][help = "destination"]),
                                 XBOX_ARG_INT_GROUP(&src, [name = src][help = "source"]),
                                 XBOX_ARG_INT_GROUPS(&other_numbers, [name = "other-number"][help = "catch the other number..."]),
                                 XBOX_ARG_END()};
    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_MULTI);
    XBOX_argparse_describe(&parser,
                           "ls",
                           "\nA brief description of what the program does and how it works.",
                           "\nAdditional description of the program after the description of the arguments.");
    XBOX_argparse_parse(&parser, argc, argv);
    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    if (XBOX_ismatch(&parser, "version")) {
        printf("v0.0.1\n");
    }
    if (XBOX_ismatch(&parser, "input")) {
        printf("i = %d\n", i);
    }
    if (XBOX_ismatch(&parser, "string")) {
        printf("s = %s\n", s);
    }
    if (XBOX_ismatch(&parser, "dest")) {
        printf("dest = %s\n", dest);
    }
    if (XBOX_ismatch(&parser, "src")) {
        printf("src = %d\n", src);
    }
    int n = XBOX_ismatch(&parser, "other-number");
    for (int i = 0; i &lt; n; i++) {
        printf("other number[%d] = %d\n", i, other_numbers[i]);
    }
    XBOX_free_argparse(&parser);
    free(s);
    free(dest);
    free(other_numbers);
    return 0;
}</code></pre><h2 id="h2-1">用法说明</h2><p>以上面的示例为例, 我们需要<b>先定义变量然后构建一个 options 并与变量绑定</b></p><pre><code class="language-c">int i;
char *s, *dest;
int src;
int *other_numbers;
argparse_option options[] = {
    XBOX_ARG_BOOLEAN(NULL, [-h][--help][help = "show help information"]),
    XBOX_ARG_BOOLEAN(NULL, [-v][--version][help = "show version"]),
    XBOX_ARG_INT(&i, [-i][--input][help = "input file"]),
    XBOX_ARG_STR(&s, [-s][--string]),
    XBOX_ARG_STR_GROUP(&dest, [name = dest][help = "destination"]),
    XBOX_ARG_INT_GROUP(&src, [name = src][help = "source"]),
    XBOX_ARG_INT_GROUPS(&other_numbers, [name = "other-number"][help = "catch the other number..."]),
    XBOX_ARG_END()
};</code></pre><p>以 <code>XBOX_ARG*</code> 开头的是宏, 第一个位置用于参数绑定, 后面的内容会被展开为字符串用于后续的解析</p><p>xargparse.h 一共提供了 8 种宏</p><ul><li><b>XBOX_ARG_BOOLEAN</b>: 适用于单参数, 例如 <code>-h</code>, 后面不需要跟其他参数信息</li></ul><ul><li><b>XBOX_ARG_INT</b>: 表示参数接收的应该是一个 int 类型的数字, 例如 <code>-i 100</code></li></ul><ul><li><b>XBOX_ARG_STR</b>: 表示参数接收的应该是一个 char* 类型的字符串, 例如 <code>-s "hello world"</code> <code>-s nihao</code></li></ul><ul><li><b>XBOX_ARG_INT_GROUP</b>: 表示接收一个组, 组中只有一个元素, 组的数据类型是 int</li></ul><ul><li><b>XBOX_ARG_INT_GROUPS</b>: 表示接收一个组, 组中至少有一个元素, 组的数据类型是 int</li></ul><ul><li><b>XBOX_ARG_STR_GROUP</b>: 表示接收一个组, 组的数据类型是 char*</li></ul><ul><li><b>XBOX_ARG_STR_GROUPS</b>: 表示接收一个组, 组中至少有一个元素, 组的数据类型是 char*</li></ul><ul><li><b>XBOX_ARG_END</b>: 表示结束, 添加在 options 数组的结尾</li></ul><p>组即不需要 <code>-</code> <code>--</code> 指定接收的正常参数, 以上面的例子为例, 如果命令行传参为: <code>./main abc 100</code>, 其中 "abc" 会被 dest 组接收, 100 会被 src 组接收, <b>需要注意的是组是有前后顺序的</b></p><p>上述参数宏分别对应不同的使用场景, 您应该合理的使用和传参, 即 <code>int</code> 对应 <code>INT</code> 和 <code>INT_GROUP</code>, <code>char*</code> 对应 <code>STR</code> 和 <code>STR_GROUP</code>, 对于若干参数的组来说您需要传递一个更深层次的指针, 即 <code>int*</code> 对应 <code>INT_GROUPS</code>, <code>char **</code> 对应 <code>STR_GROUPS</code></p><p>宏的第二个参数是该参数对应的解析配置, 其完整语法如下: <code>[-h][--help][name=abc][help="show help information"]</code>, 所有配置由一对 <code>[]</code> 包裹, <code>[]</code> 内部可以有空格, <code>[]</code> 与 <code>[]</code>之间可以有空格.</p><p>有 4 种合理的写法</p><ul><li><code>[-h]</code>: 表示短参数 h</li></ul><ul><li><code>[--help]</code>: 表示长参数 help</li></ul><ul><li><code>[name=abc]</code>: 表示此参数命名为 abc</li></ul><ul><li><code>[help="some info"]</code>: 表示参数的帮助信息</li></ul><p>其中需要注意如下几点</p><ul><li>短参数 -h 非必须, 帮助信息(help)非必须, <b>长参数与name至少有一个</b></li></ul><ul><li>长参数和name如果同时存在则必须相同, 即 <code>[--help]</code> <code>[name=help]</code></li></ul><ul><li>如果只有长参数, 则name为长参数去掉 <code>--</code> 的名字, 即 <code>--cherry-pick</code> -> name 为 <code>cherry-pick</code></li></ul><ul><li>长参数(包括--)至少 4 字节, 即 <code>--h</code> 不合法, <code>--ha</code> 合法</li></ul><ul><li>长参数默认只允许 <code>a-z_-</code> 的组合, 如果您希望使用其他字符你可手动修改其中 <code>check_valid_character</code> 函数</li></ul><ul><li>对于字符串开头结尾的 <code>"</code> 并不重要, 如果开头结尾同时存在 <code>"</code> 则会默认去掉, 即 <code>[help=ni hao ya]</code> 和 <code>[help="ni hao ya"]</code> 是等价的</li></ul><p>之后您只需要构建对象, 初始化并解析即可</p><pre><code class="language-c">XBOX_argparse parser;
XBOX_argparse_init(&parser, options, 0);
XBOX_argparse_describe(&parser, "ls", "\ndescription", "\naaa.");
XBOX_argparse_parse(&parser, argc, argv);</code></pre><p>其中有两点需要说明:</p><p><code>XBOX_argparse_describe</code> 的2 3 4位置的参数分别为 解析器的名字, 简要描述, 结尾描述</p><p><code>XBOX_argparse_init</code> 第三个参数为 flag 标记位, 用于控制解析时的选项, 默认传 0 即可.</p><ul><li><b>XBOX_ARGPARSE_IGNORE_WARNING</b>: 忽略警告</li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_STICK</b>: 允许参数粘连 <code>-O1 -Iinclude/</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_EQUAL</b>: 允许参数等号 <code>-i=123</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_MULTI</b>: 允许多个分离参数 <code>-D __KERNEL__ -D __GNU__</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_ARG_STICK</b>: 允许boolean类型参数粘连 <code>curl -Ls xxx</code></li></ul><ul><li><b>XBOX_ARGPARSE_DISABLE_SORT</b>: 帮助信息中参数不排序, 按照默认顺序输出</li></ul><p>您可以使用或运算将他们组合, 并传入 flag. 关于 flag 参数部分的相关使用会在下文配合案例介绍</p><h2 id="h2-2">接收参数</h2><p><code>XBOX_ismatch</code> 函数用于判断是否接收到了参数, 并返回匹配的个数. 第二个参数是您定义的名字或长参数的名字</p><p>如果您使用的是若干参数的组, 您可以通过接收其返回值获取,如下所示</p><pre><code class="language-c">if (XBOX_ismatch(&parser, "help")) {
    XBOX_argparse_info(&parser);
}
if (XBOX_ismatch(&parser, "dest")) {
    printf("dest = %s\n", dest);
}
if (XBOX_ismatch(&parser, "src")) {
    printf("src = %d\n", src);
}

int n = XBOX_ismatch(&parser, "other-number");
for (int i = 0; i &lt; n; i++) {
    printf("other number[%d] = %d\n", i, other_numbers[i]);
}
XBOX_free_argparse(&parser);

free(s);
free(dest);
free(other_numbers);</code></pre><p>xbox 提供了一个函数 <code>XBOX_argparse_info</code> 用于帮助信息的输出, 建议您在 options 中添加 -h 选项并将其绑定到 XBOX_argparse_info 函数, 用于辅助帮助信息的输出, 当然您也可以编写您自定义的 help 信息文档</p><p><b>xargparse 使用了动态内存分配, 所以最后请注意使用 `XBOX_free_argparse` 释放内存</b>, 对于 char<i> 类型的参数, 即用 `XBOX_ARG_STR</i><code> 的参数, 注意结束之后也应当使用 free 释放内存, 您可以利用 </code>XBOX_free_args` 完成内存释放</p><p>接下来您利用这些参数去处理您程序真正想要完成的事情了</p><h2 id="h2-3">用法实例</h2><p>如果您的参数解析器初始化存在问题, 或者解析过程出现错误, 程序会输出相应的错误提示信息, 并且内部会自动调用 free 释放内存, 您无需担心内存泄漏的问题</p><p>下面是根据上述例子的解析情况</p><h3 id="h3-4">正常情况</h3><pre><code class="language-bash">$ ./main 123 456
dest = 123
src = 456

$ ./main 123 -s 123 -i 100
i = 100
s = 123
dest = 123

$ ./main 123 -s 123 -i 100 900
i = 100
s = 123
dest = 123
src = 900

$ ./main 100 200 300 400
dest = 100
src = 200
other number[0] = 300
other number[1] = 400

$ ./src/a 100 -i 200 300 -s 400 500
i = 200
s = 400
dest = 100
src = 300
other number[0] = 500</code></pre><h3 id="h3-5">传入的参数与int不匹配</h3><pre><code class="language-bash">$ ./main 123 abc
[Args Parse Error]: argument assign to be int but get [abc]

$ ./main 123 123a1
[Args Parse Error]: argument assign to be int but get [123a1]</code></pre><h3 id="h3-6">缺少参数</h3><pre><code class="language-bash">$ ./main 123 -s
[Args Parse Error]: option [--string] needs one argument</code></pre><h2 id="h2-7">解析扩展选项</h2><p>如果您希望扩展解析时选项, 您可修改 flag 标记位</p><ul><li><b>XBOX_ARGPARSE_IGNORE_WARNING</b>: 忽略警告</li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_STICK</b>: 允许参数与值粘连 <code>-O1 -Iinclude/</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_EQUAL</b>: 允许参数等号 <code>-i=123</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_MULTI</b>: 允许多个分离参数 <code>-D __KERNEL__ -D __GNU__</code></li></ul><ul><li><b>XBOX_ARGPARSE_ENABLE_ARG_STICK</b>: 允许boolean类型参数粘连 <code>curl -Ls xxx</code></li></ul><ul><li><b>XBOX_ARGPARSE_DISABLE_SORT</b>: 帮助信息中参数不排序, 按照默认顺序输出</li></ul><p><b>XBOX_ARGPARSE_ENABLE_MULTI</b> 修饰传参时需要更深层的指针, 即 <code>int*</code> 和 <code>char **</code></p><p>不建议忽略警告, 但您可以在确保构建无误后使用 <code>XBOX_ARGPARSE_IGNORE_WARNING</code> 忽略所有警告信息</p><p>您可以使用 <code>|</code> 运算将他们组合, 并传入 flag</p><p><b>XBOX_ARGPARSE_ENABLE_ARG_STICK</b> 仅支持 BOOLEAN 类型的粘连传递, 请不要加入其他类型</p><h3 id="h3-8">忽略警告</h3><p><code>XBOX_ARGPARSE_IGNORE_WARNING</code> : 如果启用此选项, 解析时会忽略所有危险信息, 例如</p><pre><code class="language-bash"># 将下一个短参数当作解析对象
$ ./main -s -i
[Args Parse Warning]: [-i] will be passed as the argument for [-s]
s = -i

# 多个参数重复出现且未开启 XBOX_ARGPARSE_ENABLE_MULTI
$ ./main -i 100 -i 200
[Args Parse Warning]: multi argument detected for [input], covered by [200]
i = 200</code></pre><h3 id="h3-9">参数与值粘连</h3><p><code>XBOX_ARGPARSE_ENABLE_STICK</code>: 允许参数与值粘连</p><pre><code class="language-bash">$ ./main -i100
[Args Parse Error]: no match options for [-i100]</code></pre><p>修改 flag</p><pre><code class="language-c">XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_STICK);</code></pre><pre><code class="language-bash">$ ./main -i100 -sabcd
i = 100
s = abcd</code></pre><h3 id="h3-10">等号赋值</h3><p><code>XBOX_ARGPARSE_ENABLE_EQUAL</code>: 允许等号赋值</p><pre><code class="language-c">XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_EQUAL);</code></pre><pre><code class="language-bash">$ ./main -s="hello world"
s = hello world
$ ./main -s=hello
s = hello</code></pre><p>允许参数与值粘连与允许等号赋值参数赋值通常一起使用, 并优先考虑 <code>=</code> 赋值, 即对于 <code>./main -s="hello world"</code> 来说, 结果是 <code>s = hello world</code> 而不是 <code>s = =hello world</code></p><pre><code class="language-c">XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_EQUAL|XBOX_ARGPARSE_ENABLE_STICK);</code></pre><h3 id="h3-11">分离参数</h3><p><code>XBOX_ARGPARSE_ENABLE_MULTI</code>: 允许多个分离参数, 即保存为数组.</p><p>此时需要修改一下绑定的变量, 例如下例</p><pre><code class="language-c">#include &lt;xbox/xargparse.h&gt;

int main(int argc, const char **argv)
{
    char **defines = NULL;
    int *integers = NULL;
    argparse_option options[] = {
        XBOX_ARG_BOOLEAN(NULL, [-h][--help][help="show help information"]),
        XBOX_ARG_INT(&integers, [-i][--input][help="input file"]),
        XBOX_ARG_STR(&defines,[-D][--define][help="defination macros"]),
        XBOX_ARG_END()
    };
    XBOX_argparse parser;
    XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_MULTI);
    XBOX_argparse_describe(&parser,"pwd","","");
    XBOX_argparse_parse(&parser, argc, argv);
    if (XBOX_ismatch(&parser, "help")) {
        XBOX_argparse_info(&parser);
    }
    int d = XBOX_ismatch(&parser, "define");
    printf("define = ");
    for (int i=0;i&lt;d;i++) {
        printf("%s ", defines[i]);
        free(defines[i]);
    }
    free(defines);
    printf("\n");
    int k = XBOX_ismatch(&parser, "input");
    printf("integer = ");
    for (int i=0;i&lt;k;i++) {
        printf("%d ", integers[i]);
    }
    printf("\n");
    free(integers);
    XBOX_free_argparse(&parser);
    return 0;
}</code></pre><pre><code class="language-bash">$ ./src/pwd/pwd -D __KERNEL -D __GNU__ -i 100 -i 200 -i 300
define = __KERNEL __GNU__
integer = 100 200 300</code></pre><blockquote><p>这对于一些 GNU 工具的实现来说很有效</p></blockquote><h2 id="h2-12">bool参数粘连</h2><p><code>XBOX_ARGPARSE_ENABLE_ARG_STICK</code>: 支持bool类型的参数粘连, 注意与 <code>XBOX_ARGPARSE_ENABLE_STICK</code>(选项与参数粘连) 不同</p><pre><code class="language-bash">$ ./main -hv
[Args Parse Error]: Boolean argument [-h] is sticky in [-hv], do you mean XBOX_ARGPARSE_ENABLE_ARG_STICK?</code></pre><pre><code class="language-c">XBOX_argparse_init(&parser, options, XBOX_ARGPARSE_ENABLE_ARG_STICK);</code></pre><pre><code class="language-bash">$ ./main -hv
Usage: ls [OPTION]... [dest] [src] [other-number]...

A brief description of what the program does and how it works.

  -h    --help           show help information
  -i    --input          input file
  -s    --string
  -v    --version        show version
Additional description of the program after the description of the arguments.
v0.0.1</code></pre><h2 id="h2-13">参考</h2><ul><li><a href="https://github.com/cofyc/argparse" target="_blank">argparse</a></li></ul><ul><li><a href="https://github.com/SuperH-0630/fflags" target="_blank">fflags</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../libXBX/快速使用" >libXBX</a><ul><li><a href="../../libXBX/快速使用" >快速使用</a></li></ul><ul><li><a href="../../libXBX/命令行参数解析" >命令行参数解析</a></li></ul><ul><li><a href="../../libXBX/cat" >cat</a></li></ul><ul><li><a href="../../libXBX/stat" >stat</a></li></ul><ul><li><a href="../../libXBX/gnu-coreutils" >gnu-coreutils</a></li></ul></li></ul><ul><li><a href="../../LinuxC/man" >LinuxC</a><ul><li><a href="../../LinuxC/man" >man</a></li></ul><ul><li><a href="../../LinuxC/文件IO" >文件IO</a></li></ul><ul><li><a href="../../LinuxC/fcntl" >fcntl</a></li></ul><ul><li><a href="../../LinuxC/ioctl" >ioctl</a></li></ul><ul><li><a href="../../LinuxC/vfs" >vfs</a></li></ul><ul><li><a href="../../LinuxC/process" >process</a></li></ul><ul><li><a href="../../LinuxC/pipe" >pipe</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../libXBX/快速使用","../../libXBX/cat","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>