<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class='markdown-body'><h1>文件IO</h1><h2>系统调用</h2><pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);</code></pre><pre><code class="language-c">#include &lt;unistd.h&gt;

int close(int fd);</code></pre><p>参数fd是要关闭的文件描述符。当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件, 但是程序中应该手动关闭. 由open返回的文件描述符一定是该进程尚未使用的<b>最小</b>描述符。</p><h2>C 标准库</h2><pre><code class="language-c">#include &lt;stdio.h&gt;

FILE *fopen(const char *pathname, const char *mode);
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int fclose(FILE *stream);</code></pre><p>fopen(3) 会调用 oepn(2) 打开指定文件(获取文件描述符), fopen会分配一个 FILE 结构体, 其中包含该文件的描述符, IO缓冲区和当前读写位置等信息, 并返回FILE结构体的地址</p><p>fgetc(3) 通过传入的 FILE* 找到该文件描述符, IO缓冲区和当前读写位置, 判断能否从IO缓冲区读到下一个字符, 如果能读到则直接返回, 否则调用 read(2), 让内核读取该文件的数据到IO缓冲区, 然后返回下一个字符</p><p>fputs(3) 判断IO缓冲区是否有空间再存放一个字符, 如果有空间则直接保存在IO缓冲区并返回, 如果IO缓冲区已满则调用write(2)让内核把IO缓冲区的内容写回文件</p><p>fclose(3) 如果IO缓冲区还有数据没写回文件,则调用 write(2)写回文件,然后调用close(2)关闭文件,释放 FILE 结构体和 IO缓冲区</p><p>三种缓冲模式</p><ul><li>全缓冲: 缓冲区满才将调用write写入buffer, 普通文件</li></ul><ul><li>行缓冲: 缓冲区满/输入了换行符,调用write写入buffer,stdout</li></ul><ul><li>无缓冲: 无缓冲区,stderr</li></ul><p>下面的代码不会有输出,因为stdout使用行缓冲, 没有检测到换行符不会输出到终端</p><pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    
    fputc('A',stdout); // 无输出
    // fputc('\n',stdout);
    while(1) {
    }
    return 0;
}</code></pre><p>但是如果换成 stderr 会有输出, 因为无缓冲</p><pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    
    fputc('A',stderr);
    while(1) {
    }
    return 0;
}</code></pre><p>缓冲区长度为 <code>1024*sizeof(int)</code>, 也就是说如下的代码刚好不会写入. 再多写一个就会溢出.</p><pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    
    int max_buffer_length = 1024;
    for (int i=0;i&lt;max_buffer_length;i++) {
        fputc('A', stdout);
    }
    // fputc('!', stdout);
    while(1) {
    }
    return 0;
}</code></pre><h2>其他</h2><p>fputc 和 putc 基本相同, 都是将一个字符输出到 stdout, 区别在于 putc 在 glibc 中是使用宏来实现的</p><blockquote><p><a href="https://github.com/bminor/glibc/blob/master/stdio-common/printf_size.c#L28" target="_blank">https://github.com/bminor/glibc/blob/master/stdio-common/printf_size.c#L28</a></p></blockquote><pre><code class="language-c">// stdio-common/printf_size.c
#define putc(c, f) (wide \
            ? (int)_IO_putwc_unlocked (c, f) : _IO_putc_unlocked (c, f))
// libio/libio.h
#define _IO_putc_unlocked(_ch, _fp) __putc_unlocked_body (_ch, _fp)

# define _IO_getwc_unlocked(_fp)                    \
  (__glibc_unlikely ((_fp)-&gt;_wide_data == NULL              \
             || ((_fp)-&gt;_wide_data-&gt;_IO_read_ptr        \
             &gt;= (_fp)-&gt;_wide_data-&gt;_IO_read_end))       \
   ? __wuflow (_fp) : (wint_t) *(_fp)-&gt;_wide_data-&gt;_IO_read_ptr++)
# define _IO_putwc_unlocked(_wch, _fp)                  \
  (__glibc_unlikely ((_fp)-&gt;_wide_data == NULL              \
             || ((_fp)-&gt;_wide_data-&gt;_IO_write_ptr       \
             &gt;= (_fp)-&gt;_wide_data-&gt;_IO_write_end))      \
   ? __woverflow (_fp, _wch)                        \
   : (wint_t) (*(_fp)-&gt;_wide_data-&gt;_IO_write_ptr++ = (_wch)))</code></pre><blockquote><p><a href="https://github.com/bminor/glibc/blob/master/libio/fputc.c#L31" target="_blank">https://github.com/bminor/glibc/blob/master/libio/fputc.c#L31</a></p></blockquote><pre><code class="language-c">int
fputc (int c, FILE *fp)
{
  int result;
  CHECK_FILE (fp, EOF);
  if (!_IO_need_lock (fp))
    return _IO_putc_unlocked (c, fp);
  _IO_acquire_lock (fp);
  result = _IO_putc_unlocked (c, fp);
  _IO_release_lock (fp);
  return result;
}</code></pre></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../libXBX/快速使用" >libXBX</a><ul><li><a href="../../libXBX/快速使用" >快速使用</a></li></ul><ul><li><a href="../../libXBX/命令行参数解析" >命令行参数解析</a></li></ul><ul><li><a href="../../libXBX/cat" >cat</a></li></ul></li></ul><ul><li><a href="../../LinuxC/man" >LinuxC</a><ul><li><a href="../../LinuxC/man" >man</a></li></ul><ul><li><a href="../../LinuxC/文件IO" >文件IO</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../LinuxC/man",".","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
    <script type="module">
        const codeBlocks = document.querySelectorAll('.language-mermaid');
        codeBlocks.forEach(codeBlock => {
            codeBlock.classList.remove('language-mermaid');
            codeBlock.classList.add('mermaid');
        });
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>

</html>